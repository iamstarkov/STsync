{
  "name": "resource-router",
  "description": "A connect-compatible resource-orinted router for building RESTful applications",
  "version": "0.3.2",
  "author": {
    "name": "Subbu Allamaraju",
    "email": "subbu@subbu.org",
    "url": "http://www.subbu.org"
  },
  "dependencies": {
    "connect": ">= 0.3.0"
  },
  "keywords": [
    "framework",
    "rest",
    "resource",
    "restful"
  ],
  "directories": {
    "lib": "./lib/middleware"
  },
  "main": "./lib/middleware/resource",
  "readme": "\n# resource-router\n\nThis is a [Connect](https://github.com/senchalabs/connect) compatible nodejs module for handling HTTP requests. This\nmeans that all Connect features and Connect-based modules will work with the `resource-router`.\n\n# Why Another Router?\n\nUnlike the default `router` that is bundled in Connect, `resource-router` is 'resource-based'. Here is an example.\n\n    // resource-router example\n    function main(app) {\n      app.resource('/', {\n        'get' : function(req, res) {\n          res.writeHead(200, {\n            'Content-Type': 'text/html',\n            'Content-Length': body.length\n          });\n          res.end('Hello world', 'utf8');\n        }\n      });\n    }\n\n    var connect = require('connect');\n    var resource = require('resource-router');\n\n    var server = connect.createServer();\n    server.use(resource(main));\n    server.listen(3000);\n    console.log('Connect server listening on port 3000');\n\nTo implement a resource, invoke `app.resource` with the path of the resource, and then declare method support via\nan object. You can define as many methods as necessary for each resource.\n\n\n    // More methods\n    function main(app) {\n      app.resource('/', {\n        'get' : function(req, res) {\n          res.writeHead(200, {\n            'Content-Type': 'text/html',\n            'Content-Length': body.length\n          });\n          res.end('Hello world', 'utf8');\n        },\n        'put' : function(req, res) {\n          res.writeHead(201, {\n            'Content-Type': 'text/html',\n            'Location': 'http://localhost:3000/1'\n          });\n          res.end('Created', 'utf8');\n        },\n        'delete' : function(req, res) {\n          res.writeHead(200, {\n            'Content-Type': 'text/html'\n          });\n          res.end('Deleted', 'utf8');\n        }\n      });\n    }\n\nresource-router automatically adds support `HEAD` and `OPTIONS` methods.\n\n    GET /somepath HTTP/1.1\n    Host: localhost:3000\n\n    204 No Content\n    Allow: GET,HEAD\n\nContrast this to the default `router` in Connect.\n\n    // This is the same example with Connect. Don't use with resource-router.\n    function main(app){\n      app.get('/', function(req, res) {\n          res.writeHead(200, {\n            'Content-Type': 'text/html',\n            'Content-Length': body.length\n          });\n          res.end('Hello world', 'utf8');\n      });\n      app.put('/', function(req, res) {\n         // implement PUT here\n         ...\n      });\n      app.delete('/', function(req, res) {\n         // implement PUT here\n         ...\n      });\n    }\n\nThough the differences seem syntactical, there is a fundamental difference here. The right programming model to\nwrite HTTP applications is to implement various HTTP methods for each resource. That is, you must start with a\nresource and then specify what methods you want to support for that resource. Connect's `router` module takes the\nopposite (and wrong) approach. Use `resource-router` to get the right HTTP orientation.\n\n# Installation\n\n    npm install resource-router",
  "readmeFilename": "README.md",
  "_id": "resource-router@0.3.2",
  "dist": {
    "shasum": "6ea19127beb4f66fdec2dbf561948b38d476e71f"
  },
  "_from": "resource-router"
}
